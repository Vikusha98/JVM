package ru.netology;

public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      //1.объявляется переменая i примитивного типа, инициализируется згачением
                                   // Это происходит в стеке памяти, внутри фрейма, который создается для метода main.

        Object o = new Object();        // 2.создается новый объект object в heap (куча).
                                        // Ссылка на этот объект хранится в переменной о, которая хранится в стеке
                                         //  памяти, внутри фрейма метода main. В данном случае задействуетя ClassLoader,
                                        //  который загружает класс Object.
        Integer ii = 2;                 //3. В куче создается новый объект Integer, ссылка на который хранится в
                                        // переменной ii. Переменная ii находится в стеке памяти, внутри фрейма метода
                                        // main. В данном случае задействуетя ClassLoader,
        //                                        //  который загружает класс Integer.
        printAll(o, i, ii);             // 4. Здесь вызывается метод printAll. Для этого создается фрейм в стеке
                                        // памяти. В этом фрейме создаются три переменные, которые получают копии
                                        // значений переменный o, i, ii.
        System.out.println("finished"); // 7. После завершения метода printAll его фрейм удаляется из стека.
         // Затем вызывается метод println с аргументом "finished". Для этого создается новый фрейм в стеке памяти.
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5. Внутри фрейма метода printAll создается новый объект Integer
                // в куче. Ссылка на этот объект хранится в переменной uselessVar, которая находится в стеке памяти.
        System.out.println(o.toString() + i + ii);  // 6. Вызывается метод println. Для этого создается новый фрейм в
        // стеке памяти. В этом фрейме создаются переменные для хранения результатов вычислений и ссылок на объекты,
        // которые используются в процессе выполнения метода. После завершения метода main его фрейм также удаляется
        // из стека. В этот момент JVM может запустить сборщик мусора, чтобы очистить кучу от объектов, которые
        // больше не доступны для использования (в данном случае, это объекты o, ii и uselessVar).
    }
}